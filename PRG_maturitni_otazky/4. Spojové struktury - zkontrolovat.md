- prvky jsou v paměti rozházené a pouze na sebe odkazují 
- každý prvek nese informaci, kde se nachází následující prvek
- vždy obsahují kořen = root node (první uzel = first node)

### Spojový seznam (linked list)

- pokud uzly obsahují informaci o svém předchůdci => **obousměrný spojový seznam**
- pokud poslední prvek odkazuje na první prvek => **kruhový spojový list**
- jde o vytvoření "řetězu"
![[Pasted image 20230208081246.png]]

- **výhody** (oproti poli)
	- není omezen pevnou délkou, lze položky flexibilně přidávat / odebírat
	- jednoduše se vkládají prvky doprostřed seznamu
	- prvky nelze přesouvat => pouze se přepíše jejich ukazatel na další prvek
- **nevýhody**
	- nelze efektivně přeskočit na n-tý prvek (indxování), vždy je nutné jít postupně 
- **časová složitost**
	- najdi prvek: O(n)
	- přidej na začátek: O(1)
	- přidej prvek někam: O(n)
	- smaž prvek: O(n)

#### Shrnutí

Spojový seznam se hodí pro operace, kde nepotřebujeme indexovat prvky, ale potřebujeme je efektivně vkládat a mazat => především pokud je vkládáme na neurčitá místa, nikoliv vždy na konec / začátek seznamu

### Fronta (Queue)

- kolekce, která má 2 základní funkce => **přidat (queue)** a **vymazat (enqueue)**
- funkce pro přidání vždy přidává prvek na konec řady
- funkce pro vymazání vždy odebírá prvek ze začátku fronty
![[Pasted image 20230208081920.png]]

#### Shrnutí 

Fronta se používá v případech, kdy chceme zachovat stejné pořadí prvků, jako když přišli (FIFO - first in, first out). Typickým příkladem je fronta u doktora, či pořadník => prvky se staví za sebe a ve stejném pořadí se dostávají z fronty ven.

### Zásobník (stack)

- kolekce, která má 2 základní funkce => **přidat (push)** a **vymazat (pop)**
- funkce pro přidání vždy přidá prvek na začátek fronty
- funkce pro vymazání vždy odebírá prvek ze začátku fronty
![[Pasted image 20230208082220.png]]

#### Shrnutí

Zásobník se používá v případech, kdy chceme nejdříve vyjmout prvky, které jsou v zásobníku nejkratší čas (LIFO - last in, first out). Typickým příkladem je sud => prvky se skládají na sebe a pokud se chceme dostat k nejspodnějšímu => musíme odstranit všechny prvky, které se nachází nad ním. 

### Binární strom (binary tree)

- z kořenu vedou další uzly - každý uzel má nejvýše 2 potomky (binary tree)
- v každém uzlu je uložen právě jeden prvek
- větev stromu končí, když daný uzel nemá žádné další potomky
![[Pasted image 20230208082558.png]]

- podle logiky uložení dat se binární stromy můžou dělit na různé kategorie

#### **Halda** (heap)

- každá úroveň haldy je menší / větší než ta předchozí
![[Pasted image 20230208083750.png]]

#### **Vyvážený vyhledávací strom**

- pravá větem nese vždy vyšší hodnotu, než daný uzel 
- levá větev nese naopak menší hodnotu
- **Samovyvažovací strom**
	- stromy mají navíc funkci pro kontrolu vyváženosti + její zpětné obnovení
	- AVL stromy = rozdíl hloubky je max 1
	- B-stromy = více prvků na jednom uzlu

#### **Nevyvážený strom a graf**

#### Shrnutí

Binární stromy se používají hlavně při vyhledávání, kde lze pole prvků upravit na formátovaný strom. Díky tomu v něm lze nalézt data rychleji než v jiných strukturách.