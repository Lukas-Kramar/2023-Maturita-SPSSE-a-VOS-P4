### Návrhové vzory pro skrývání implementace
### Návrhové vzory pro optimalizaci rozhraní

**Potřeba zkontrolovat a dát smyslupné příklady použití od Pospiho - bohuže jsem je zapoměl + roztřadit vzory do kategorií (nahoře)** 


### Proxy (zástupce)

- nahrazuje přístup k zastupované hodnotě
	- nenbo může sloužit jako "buffer" => posíláme příkazy na server, které se ale hned neodešlou
- v případě, že daná hodnota má nějaké omezení přístupu
- implementuje se pomocí rozhraní / abstraktní třídy
- příklady:
	- serverová proxy
	- internetová proxy
	- proxy pro API

### Command (příkaz)

- mění funkce na objekty s nimiž se dá pracovat (podobná delegátům)
- má připravené metody a uživatel do nich musí dostat parametry
- příkazů lze vytvářet více veedle sebe
- příklady:
	- objednávka v restauraci

### Iterator

- zpostředkovává přístup k objektům v kolekci
	- jedná se o 2 důležité metody:
		- **HasNext()**
		- **GetNext()**
- implementace jeho struktury je skrytá
- může se použít buď externí, nebo interní
- příkladem je cyklus foreach (systematické procházení kolekcí)

### State

- používá se v případě, že mezi stavy objektu je velký rozdíl
- implementuje se objekt, který reprezentuje stav pomocí stavových tříd
- dělí se na stavově závislé a nezávislé části
- příklady:
	- auto s automatiickou převodovkou

### Template metoda

- v případě, že chceme, aby podtřídy mohli upravovat kroky algoritmu
- rozdíl oproti template tříde - List<*něco*>...
	- u třídy se nastavuje datový typ
	- u template metody nastavujeme / měníme algoritmus
- některé její funkce definuje až příslušná podtřída
- abstraktní / virtuální metody
- příklady:
	- denní rutina zaměstnance

### Facade (fasáda)

- pro zjednodušení komunikace
- snižuje počet objektů nutných ke komunikaci
- používá se na centralizaci a snížení duplicity kódu 
- příklady:
	- máme 3 rozhraní každé o 3 metodách => chceme zprovoznit objekt, který dává "ven" pouze 6 z těchto metod => vytvoříme fasádu

### Adapter

- pro změnu rozhraní objektu
- vyžaduje kompletní implementaci rozhraní
- usnadňuje definici nových tříd a zabezpečí spoluprárci existujících
- vhodné při práci na rozpracovaných projektech (oddělíme řešení komuniakce s extermími zdroji od hlavní části našeho projektu)
- příklad:
	- firma se chystá změnit GET metodu v API (přidá parametry) => vytvořím si adaptér v mém projektu, který se bude tvářit jako už změněný endpoint API => v něm osekám zaslané data programu o přidané parametry => pošlu na API (kde ještě neproběhla chystaná úprava)

