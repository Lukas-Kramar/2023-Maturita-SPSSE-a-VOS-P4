# Asynchronní a paralelní programování
---

### Asynchroní a paralelní programování

- standratně se kód vykonává postupně (synchronně) v jednom vláknu
- asynchronní programování vytváří úlohy, které běží současně (více vláknově = paralelizace)
	- každá úloha má vlastní vlákno

### Thread (vlákno)

- v C# se jedná o třídu Thread
- vytvořením instance této třídy vytvoříme nové vlákno procesoru
- 
- metody (**všechno je v dokumentaci stačí hledat**):
	-   **Start()** - This method starts the execution of a new thread.
	-   **Join()** - This method blocks the calling thread until the thread on which it is called completes.
	-   **Sleep()** - This method suspends the current thread for a specified amount of time.
	-   **Abort()** - This method aborts the thread on which it is called.
	-   **Interrupt()** - This method interrupts a blocked thread by throwing a ThreadInterruptedException.
	-   **Resume()** - This method resumes a suspended thread.
	-   **Suspend()** - This method suspends a running thread.
	-   **Yield()** - This method yields the processor to other threads.
	-   **GetId()** - This method returns the unique identifier of the current thread.
	-   **IsAlive()** - This property indicates whether the thread is currently executing or not.
	-   **IsBackground()** - This property indicates whether the thread is a background thread or not.


### Task (úloha)

- asynchronní úloha
- v C# se jedná o generickou třídu Task
- nachází se na vyšší abstraktní úrovni než Thread
	- jednodušší na vytvoření a může běžet na kterékoliv vlákně z jejich poolu
	- existence Task Scheduleru => flexibilnější plánování než u vytváření a managování vláken ručně (Thread)
	- exepctions are automatically propagated to the parent Task or to the Task that awaits it (u Thread je musíme explicitně "chytat")
	- mohou vracet hodnotu (Thread ne)
- vytvořením instance této třídy vytvoříme novou úlohu
	- obsahuje info o úloze

- metody (**všechno je v dokumentaci stačí hledat**):
	- **Start()** - odstartuje úlohu
	- **Wait()** - počká dokud vlákno nedokončí svou práci, až pak ho může řídící vlákno znovu zavolat
	- **ContinueWith()** - můžeme specifikovat, který další Task se má po dokončení spustit    
	- **WhenAll()** - This method waits for all of the specified tasks to complete => nezablokuje volající vlákno, které může pokračovat v práci  
	- **WhenAny()** - This method waits for any of the specified tasks to complete.   
	- **Result()** - This property retrieves the result of the task if it has completed.
	- **WaitAll()** - This method waits for all of the specified tasks to complete. zablokuje řídící (calling) vlákno => čeká na dokončení všech ostatních vláken
	- **WaitAny()**: This method waits for any of the specified tasks to complete.
	- **IsCompleted()** -  This property indicates whether the task has completed or not.
	- **IsFaulted()** - This property indicates whether the task has encountered an exception or not.
	- **Dispose()** -  This method releases all resources used by the task.

### Lock (zámek)

- při paralením programování může nastat situace, kdy bude více vláken "šahat" a měnit stejná data => nežádoucí výsledky a chyby
- Locku můžeme jako parametr předat jakýkoliv objekt
	- tímto objektem se daná část kódu zamkne
- zamknutá část se musí vždy dokončit, než se data znovu zpřístupní
- Lock můžeme zaměnit za třídu `Monitor` => jednodušší zápis pro programátora
	- metody `Enter()` a `Exit()`

#### Příklad kódu

```Csharp
class Program
{
    static object lockObject = new object();
    static int sharedVariable = 0;

    static void Main(string[] args)
    {
        Thread t1 = new Thread(Increment);
        Thread t2 = new Thread(Increment);

        t1.Start();
        t2.Start();

        t1.Join();
        t2.Join();

        Console.WriteLine("Shared variable value: " + sharedVariable);
    }

    static void Increment()
    {
        for (int i = 0; i < 100000; i++)
        {
            Monitor.Enter(lockObject);
            sharedVariable++;
            Monitor.Exit(lockObject);
        }
    }
}

```

- `lockObject` is used as a shared lock to synchronize access to the `sharedVariable` field. 
- `Increment()` method is executed by two threads concurrently
- `Monitor.Enter()` method is used to acquire the lock before accessing the shared variable
- `Monitor.Exit()` is used to release the lock after accessing it. 
- **This ensures that only one thread can access the shared resource at a time, preventing race conditions and ensuring thread-safety.**
- výsledek kódu bude 2000 => protože každé vlákno incrementnulo číslo pouze ve chvíli, kdy ho mělo zalockovaný => nenastala chyba se současným přístupem dvou vláken

### Použití paralelního programování

- podmínkou je vlastnit hardware, umožňující paralelizaci = více logických jader (existuje i softwarová obdoba od OS - multitasking, ale není to moc supr čupr)
- hodí se pro výpočty, které pracují s velkým množstvím na sobě nezávislých dat
- př. použití v uživatelském rozhraní (jedno vlákno), nově založené vlákno je nějaký náročný proces => při vykonávání složité úlohy nám GUI "nezamrzne", protože běží na jiném vlákně

### Async / await

- klíčová slova v C#, která umožňují vytvářet asynchroní funkce
- `async` označuje metodu jako asynchroní
	- musí obsahovat await (ve svém těle)
	- po zavolání `await` se počká na dokončení metody
	- metodu by měla vracet instanci `Task`


### Praktická část

- naprogramovat thread save singleton => hodim ho do locku
- v dokumentaci jsou příklady všeho = Join, ThreadStart ()...
-  **Naučit se pracovat v microsoft dokumentaci!!**