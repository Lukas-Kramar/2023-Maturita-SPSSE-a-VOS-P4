
### Omezení a rozdíly vůči programování pro osobní počítače

- absennce operačního systému (u jednodušších mcu)
	- absence dynamické alokace paměti
	- přímý přístup k HW
- norma vychází z jazyka C
	- s omezenými možnostmi (např. paměť)
- navíc se zde oproti PC nachází instrukce, které manipují s jednotlivými bity
	- `SET`, `CLEAR`, `TEST`
- někdy je nutno softwarově implementovat zásobník / stack (přes ukazatel / pointer)
- **omezená nebo zakázaná rekurze**

#### Datové typy

- většina datových typů je podporována
- oproti "klasickému PC" je zde datový typ bit
- proměnné lze určit jako "volatile" => možnost je asynchroně měnit

### Vhody a nevýhody použití assembleru

- kvalitní kód dostáhne vyšší úrovně optimalizace
- delší doba tvorby kódu
- menší přesnost
- kód není přenosný
- u některých programů se v assembleru optimalizují pouze určité části

### Požadavky vyšších programovacích jazyků na architekturu MCU

#### Použití vyšších programovacích jazyků z důvodu:

- snížení kódové nadbytečnosti
- efektivní implementace typických konstrukcí
	- pole, větvení, podprogramy...

#### Požadavky

- **více pracovních registrů**
	- charakteristika RICS architektur
	- data se nemusí pokaždé načítat z paměti
- **krátký instrukční cyklus**
	- charakteristika RICS architektur
	- ideálně jeden cyklus na instrukci
- **rozšířená podpora ukazatelů**
	- pro přístup k datům
	- pre-dekrement a post-inkrement
- **indexování polí**
	- relativní adresy pro přístup k prvkům pole
	- ukazatel je na začátek pole a obsahuje učtiý offset (slouží jako index)
- **šíření příznnaku nuly**
	- instrukce v sobě zahrnuje výsledek předchozí operace
		- npř. číslo má více bitů než máme k dispozi => pamatujeme si, že porovnání prvních bitů ukázalo neshodu => výsledek operace bude vyhodnocen jako neshoda (i když by se porovnání druhé části čísla / poslední operace rovnalo shodě)
	- příkladem jsou instrukce "... witch carry"
- **bitové proměnné**
	- používají se pro zjištění hodnoty na portech a reprezentaci hodnoty true / false
	- samotná skupina instrukcí v instrukčním souboru
		- `SET`, ,`CLEAR`, `TEST`
- **ukazatel na zásobník**
	- stack pointer
	- díky němu je možno instrukci i operand číst v jednom cyklu

### Optimalizace kompilátoru

- základ optimalizace je správný návrh kódu od programátora
- dělí se na:
	- optimalizace závislé na hardwaru
		- vyžadují podporu od zařízení (mcu)
	- optimalizace nezávislé na hardwaru

#### Optimalizace závislé na hardwaru

- **registrované proměnné**
	- proměnné a parametry funckí se umisťují do registrů místo operační paměti
- **optimalizace jednoduchým přístupem**
	- kompilátor využije nejvíce se hodící instrukce pro danou činnost
		- např. bitové instrukce pro porovnávání bitů
		- operace jejichž výsledkem je nastavení / nulování / testování jednotlivých bitů
- **regorganizace kódu**
	- změny typu smyčky (kompilátor použije FOR místo WHILE, je-li to efektivnější)
	- někdy je efektivnější čítat z druhé strany a testovat na 0 (místo testování vrchní číselné hodnoty)

#### Optimalizace nezávislá na hardwaru

 **Zpracování konstant**
 - výpočty s více konstantami lze provést v době kompilace

 **Vyloučení opakujících se výpočtů**
 - kompilátor si může uložit hodnotu, když zjistí, že bude v budoucnu znova potřeba
- hodnoty se ukládají do registrů

**Optimalizace skokových příkazů**
- některé vnořené příkazy lze nahradit skokem přímo na cílovou adresu
- kompilátor volí, zda použije absolutní, nebo relativní skok podle délky skoku
	- **relativní** = skoč o určitý počet bitů (adres) dopředu / dozadu
	- **absolutní** = skoč přímo na tuhle novou adresu
- vnořené skoky / větvení sloučíme (pokud to lze)

 **vyloučení "mrtvého" kódu**
- pokud se v programu nachází kód, který nikdy nebude proveden => kompilátor ho odstraní
- týká se "nedosažitelného kódu" (npř. za returnem)

**nahrazení opakujících se úseků programu skoky**
- pokud program zjistí, že se určité instrukce opakují => vytvoří pro ně podprogram
	- program skočí na začátek těchto instrukcí (podprogram)

**negace skoků**
- jednu větev podmínky lze odstranit negací podmínky

 **optimalizace plnění**
- při inicializaci proměnných lze nastavit nějakou počáteční hodnotu
	- npř. proměnnou "pro jistotu" vymazat
	- pokud program zjistí, že se proměnná nepoužívá => inicializaci může vynechat
- obsah proměnné je přepsán dříve, než je původní hodnota použita (nadbytečná inicializace)

**optimalizace jednoduchých cyklů**
- místo použití cyklů lze kód nakopírovat za sebou
- pokud můžeme některý kód "vyhodit" před smyčku
- zvyšuje velikost paměti programu, na druhou stranu ho ale zrychlí

**rotace smyček**
- lze zaměnit pořadí prováděných instrukcí (pokud na sobě nejsou závislé)
	- instrukce se stejnými proměnnými "dáme" k sobě

- **rotatce řídícího toku**
	- náhrada za switch-case
	- switch-case se převádí na if
	- pokud jednotlivé podmínky tvoří kaskádu => lze skočit přímo na správnou větev

### Optimalizace kompilátoru (praktická ukázka)
